---
layout: default
title: \[BOJ\] ìŠ¤ë„ì¿ 
date: 2023-12-22 14:54 +0900
# last_modified_at: 2024-01-01 00:00 +0900
hit_count: false
utteranc: true
permalink: /docs/ps/boj/2580
parent: Problem Solving
categories:
  - Problem Solving
  - BOJ
---

# \[BOJ\] 2580 ìŠ¤ë„ì¿  C++
{: .no_toc }
<details open markdown="block">
  <summary>
    Table of contents
  </summary>
  {: .text-delta }
- TOC
{:toc}
</details>

<hr>

[ë¬¸ì œ ë§í¬](https://www.acmicpc.net/problem/2580)

ìŠ¤ë„ì¿ ì˜ ë¹ˆ ì¹¸ì„ ì±„ìš°ëŠ” ë¬¸ì œ. ğŸš¨ì •ë‹µì´ ì—¬ëŸ¬ ê°œì¼ ìˆ˜ ìˆë‹¤.

<hr>

## í’€ì´ ê³¼ì •

1. íŠ¹ì • ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ìƒíƒœë¥¼ ì°¾ëŠ” íƒìƒ‰ ë¬¸ì œì´ë‹¤.
2. íƒìƒ‰ì˜ ë°©ë²•ì—ëŠ” ì„¸ ê°€ì§€ê°€ ìˆë‹¤. 
    * ë°˜ë³µë¬¸ìœ¼ë¡œ brute force.
    * BFS - ê·¸ë˜í”„ë¡œ í‘œí˜„ë˜ëŠ” ìƒíƒœê³µê°„ì„ íƒìƒ‰í•˜ê¸° ì í•©í•˜ë‹¤.
    * DFS - ê·¸ë˜í”„ì™€ íŠ¸ë¦¬ë¡œ í‘œí˜„ë˜ëŠ” ìƒíƒœê³µê°„ì„ íƒìƒ‰í•˜ê¸° ì í•©í•˜ë‹¤.
3. ì´ ë¬¸ì œëŠ” íŠ¸ë¦¬ë¡œ í‘œí˜„ë˜ê¸° ë•Œë¬¸ì— DFSê°€ ì í•©í•˜ë‹¤. (`for`ë¬¸ì„ ì“°ë©´ Nì¤‘ì²© ì½”ë“œë¥¼ ì‘ì„±í•´ì•¼ í•œë‹¤.)
4. íŠ¸ë¦¬ì˜ ë…¸ë“œê°€ ê°€ì§€ëŠ” ìƒíƒœ
    * `vector<vector<int>> sudoku` í˜„ì¬ ìŠ¤ë„ì¿  íŒì˜ ëª¨ë“  ìˆ«ì
    * `vector<vector<int>> emptySpaces` ë¹ˆ ì¹¸ë“¤ì˜ ì¢Œí‘œê°’
    * `int d` ê¹Šì´ (í˜„ì¬ ë¹ˆ ì¹¸ì„ ëª‡ ê°œê¹Œì§€ ì±„ì› ëŠ”ì§€ë¥¼ í‘œí˜„)
    * `bool answerFound` ì •ë‹µì´ ì—¬ëŸ¬ê°œì¼ ê²½ìš°, í•œ ê°œì˜ ë‹µì„ ì„ íƒí•˜ê¸° ìœ„í•œ í”Œë˜ê·¸
5. ì¬ê·€í˜¸ì¶œ ì¢…ë£Œ ì¡°ê±´
    * `d == emptySpaces.size()` ëª¨ë“  ë¹ˆ ì¹¸ì´ ì±„ì›Œì§„ ê²½ìš°
    * `answerFound == true` ì´ë¯¸ ì •ë‹µì„ êµ¬í•œ ê²½ìš°
6. ì´ëŒ€ë¡œ ì•Œê³ ë¦¬ì¦˜ì„ ì‘ì„±í•  ê²½ìš° 9á´ºê°œì˜ ë…¸ë“œë¥¼ íƒìƒ‰í•˜ê²Œ ë˜ê³  ë‹¹ì—°íˆ ì‹œê°„ì´ˆê³¼ì´ë‹¤. íƒìƒ‰í•  í•„ìš”ê°€ ì—†ëŠ” ë…¸ë“œëŠ” íƒìƒ‰í•˜ì§€ ì•ŠëŠ” ë°±íŠ¸ë˜í‚¹ ì¡°ê±´ì´ í•„ìš”í•˜ë‹¤.
    * ìƒˆë¡œ ì¶”ê°€í•  ìˆ«ìê°€ ê·œì¹™ì„ ë§Œì¡±í•˜ëŠ” ê²½ìš°ì—ë§Œ íŠ¸ë¦¬ í™•ì¥
7. psuedo code

```
void dfs(board, d, answerFound, emptySpaces) {
    if (answerFound) {
        return;
    }
    if (d == emptySpaces.size()) {
        ì •ë‹µ ì¶œë ¥
        answerFound = true;
        return;
    }
    for (int i = 1; i <= 9; i++) {
        x = emptySpaces[d][0];
        y = emptySpaces[d][1];
        if (okayToInsert(board, x, y, i)) {  // ìƒˆë¡œ ì¶”ê°€í•  iê°€ ê·œì¹™ì„ ë§Œì¡±í•˜ëŠ”ì§€ í™•ì¸
            board[x][y] = i;
            dfs(board, d + 1, N, answerFound, emptySpaces);
            board[x][y] = 0;
        }
    }
}
```
<hr>

## ì •ë‹µ ì½”ë“œ

```cpp
#include <cstdlib>
#include <iostream>
#include <vector>
using namespace std;

const int N = 9;

bool okayToInsert(const vector<vector<int>>& sudoku, int x, int y, int v) {
    for (int i = 0; i < N; i++) {
        if (sudoku[x][i] == v)
            return false;
        if (sudoku[i][y] == v)
            return false;
    }
    int sqx = x / 3 * 3;
    int sqy = y / 3 * 3;
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            if (sudoku[sqx + i][sqy + j] == v)
                return false;
        }
    }
    return true;
}

void dfs(vector<vector<int>>& sudoku, const vector<vector<int>>& emptySpaces, int d, bool& hit) {
    if (hit) {
        return;
    }
    if (d == emptySpaces.size()) {
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++){
                cout << sudoku[i][j] << " ";
            }
            cout << endl;
        }
        hit = true;
        return;
    }
    for (int i = 1; i <= N; i++) {
        int x = emptySpaces[d][0];
        int y = emptySpaces[d][1];
        if (okayToInsert(sudoku, x, y, i)) {
            sudoku[x][y] = i;
            dfs(sudoku, emptySpaces, d + 1, hit);
            sudoku[x][y] = 0;
        }
    }
}

int main() {
    cin.tie(NULL);
    cout.tie(NULL);
    ios::sync_with_stdio(false);

    vector<vector<int>> emptySpaces;
    vector<vector<int>> sudoku(N, vector<int>(N, 0));
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            cin >> sudoku[i][j];
            if (sudoku[i][j] == 0)
                emptySpaces.push_back(vector<int>{i, j});
        }
    }
    bool hit = false;
    dfs(sudoku, emptySpaces, 0, hit);

    return 0;
}

```
